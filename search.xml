<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT1034]]></title>
    <url>%2F2018%2F07%2F01%2FPAT1034%2F</url>
    <content type="text"><![CDATA[PAT1034 Head of a Gang (30) 题目 代码 #include &lt;iostream> #include &lt;vector> #include &lt;algorithm> using namespace std; struct Elem { bool isExist; int weight; int gangNo; }; struct Gang { int head; int num; int weight; }; struct Result { int index; int num; bool operator&lt;(Result other) { return index &lt; other.index; } }; struct Input { int name1; int name2; int weight; bool operator&lt;(Input other) { if (name1 == other.name1) { return name2 &lt; other.name2; } else { return name1 &lt; other.name1; } } }; int name2index(const char *name) { int index = 0; index = (name[2] - 'A') + (name[1] - 'A') * 26 + (name[0] - 'A') * 26 * 26; return index; } void index2name(int index, char *name) { name[0] = index / 26 / 26; name[1] = (index - name[0] * 26 * 26) / 26; name[2] = index - name[0] * 26 * 26 - name[1] * 26; name[0] += 'A'; name[1] += 'A'; name[2] += 'A'; name[3] = '\0'; } int main() { int N, K; scanf("%d%d", &amp;N, &amp;K); vector&lt;Elem> data(17600); // 初始化 for (int i = 0; i &lt; 17600; ++i) { data[i].isExist = false; data[i].weight = 0; data[i].gangNo = -1; } int gangNum = 0; vector&lt;Input> inputs(N); for (int i = 0; i &lt; N; ++i) { char name1[5], name2[5]; int weight; scanf("%s%s%d", name1, name2, &amp;weight); inputs[i].name1 = name2index(name1); inputs[i].name2 = name2index(name2); inputs[i].weight = weight; } //sort(inputs.begin(), inputs.end()); for (int i = 0; i &lt; inputs.size(); ++i) { int index1 = inputs[i].name1; int index2 = inputs[i].name2; int weight = inputs[i].weight; // 填充数据 if (data[index1].isExist &amp;&amp; !data[index2].isExist) { data[index2].gangNo = data[index1].gangNo; data[index2].isExist = true; data[index1].weight += weight; data[index2].weight += weight; } else if (!data[index1].isExist &amp;&amp; data[index2].isExist) { data[index1].gangNo = data[index2].gangNo; data[index1].isExist = true; data[index1].weight += weight; data[index2].weight += weight; } else if (!data[index1].isExist &amp;&amp; !data[index2].isExist) { data[index1].gangNo = gangNum; data[index2].gangNo = gangNum; gangNum++; data[index1].isExist = true; data[index2].isExist = true; data[index1].weight += weight; data[index2].weight += weight; } else { if (data[index1].gangNo != data[index2].gangNo) { int tmpNo = data[index2].gangNo; for (int i = 0; i &lt; 17600; ++i) { if (data[i].isExist &amp;&amp; data[i].gangNo == tmpNo) { data[i].gangNo = data[index1].gangNo; } } data[index1].weight += weight; data[index2].weight += weight; } else { data[index1].weight += weight; data[index2].weight += weight; } } } // 将所有团体的heads都求出来，以及所有团体人的个数 vector&lt;Gang> gangs(gangNum); // 初始化gangs for (int i = 0; i &lt; gangNum; ++i) { gangs[i].head = -1; gangs[i].num = 0; gangs[i].weight = 0; } for (int i = 0; i &lt; 17600; ++i) { if (data[i].isExist) { int noG = data[i].gangNo; gangs[noG].weight += data[i].weight; ++gangs[noG].num; if (gangs[noG].head == -1) { gangs[noG].head = i; } else { if (data[i].weight > data[gangs[noG].head].weight) { gangs[noG].head = i; } } } } vector&lt;Result> results; for (int i = 0; i &lt; gangNum; ++i) { if (gangs[i].num > 2 &amp;&amp; gangs[i].weight > K * 2) { Result tmp; tmp.index = gangs[i].head; tmp.num = gangs[i].num; results.push_back(tmp); } } sort(results.begin(), results.end()); printf("%d\n", results.size()); for (int i = 0; i &lt; results.size(); ++i) { char name[5]; index2name(results[i].index, name); printf("%s %d\n", name, results[i].num); } return 0; } 总结该问题的解题思路就如代码所示，先将所有的通话记录保存下来，将每个人的名字都对应为一个整数，例如‘AAA’代表0（26进制）对这些输入数据进行分析，分析过程如下： 如果第一人出现过，第二人没出现，则将第二人加入第一人帮派，两人都加weight值； 如果第一人没出现，第二人出现过，则将第一人加入第二人帮派，两人都加weight值； 如果两人都没出现过，则将两人加入到新帮派，两人都加weight值； 如果两人都出现过，分两种情况： 两人同属一个帮派，只加weight值； 两人不属于一个帮派，遍历整个数组，需将其中一人帮派成员全部合并到另一人帮派中，两人都加weight值。（易错点） 处理过后，遍历整个数组，将成员信息加入到帮派数据结构中，最后整合信息，将所需要的结果打印出来即可。 同样可以使用网上的办法：并查集，附别人的代码参考。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1033]]></title>
    <url>%2F2018%2F06%2F30%2FPAT1033%2F</url>
    <content type="text"><![CDATA[PAT1033 To Fill or Not to Fill (25) 题目 代码 #include &lt;iostream> #include &lt;vector> #include &lt;algorithm> #include &lt;iomanip> using namespace std; struct Station { double price; int dist; bool operator&lt;(Station other) { return dist &lt; other.dist; } }; int main() { int Cmax, D, DperU, N; cin >> Cmax >> D >> DperU >> N; vector&lt;Station> stations; for (int i = 0; i &lt; N; ++i) { double price; int dist; cin >> price >> dist; Station s; s.price = price; s.dist = dist; stations.push_back(s); } sort(stations.begin(), stations.end()); // 将终点站设置为一个油价为0的站 Station final_station; final_station.price = 0.0; final_station.dist = D; stations.push_back(final_station); double cur_dist = 0; int MAX_DIST = DperU * Cmax; double cur_price = 0.0; int cur_station = 0; int cur_gas_dist = 0; bool noGas = false; // 考虑起始点有没有加油站 if (stations[0].dist != 0) { noGas = true; } while (!noGas &amp;&amp; cur_dist &lt; D) { int bet_dist = stations[cur_station + 1].dist - stations[cur_station].dist; // 代表不能到达目的地 if (bet_dist > MAX_DIST) { cur_dist += MAX_DIST; break; } // 可能的下一站 int next_station = cur_station + 1; // 设置一个标志，表示下一趟经过的加油站油价都比较贵 bool better = false; while (stations[next_station].dist - stations[cur_station].dist &lt;= MAX_DIST) { if (stations[next_station].price &lt; stations[cur_station].price) { better = true; break; } else { next_station++; } } if (!better) { next_station = next_station - 1; for (int i = next_station; i > cur_station; --i) { if (stations[i].price &lt; stations[next_station].price) { next_station = i; } } } // 目前已经确定了下一站的位置 cur_dist = stations[next_station].dist; if (!better) { cur_price += (double)(Cmax * DperU - cur_gas_dist) / DperU * stations[cur_station].price; cur_gas_dist = stations[cur_station].dist + Cmax * DperU - stations[next_station].dist; } else { cur_price += ((double)(stations[next_station].dist - stations[cur_station].dist - cur_gas_dist) / DperU) * stations[cur_station].price; cur_gas_dist = 0; } cur_station = next_station; } if (cur_dist &lt; D) { cout &lt;&lt; "The maximum travel distance = " &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; cur_dist; } else { cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; cur_price; } } 总结该问题是一个常见的贪心问题，我们需要求得任意局部的最优解从而达到整体的最优解。对于本题而言，计算油价的最小值等价于计算如何根据油价和路程的不同，在每一个站点添加不同的油量。主要的解题思路如下： 考虑当前站C站能否到达下一站，若能到达，转为2；若到不了则打印所能行驶的最远距离为当前站的距离加上Cmax*DperU（最远距离）。 若能到达，继续考虑以下两种情况： 在该站能到达的最远距离所途经的所有加油站中，若有价位比当前C站低的站，则将油加到能到达此站即可。 在该站能到达的最远距离所途经的站中，若所有站点的油价均高于C站，则在C站将油加满，并且到达其中油价最低的站点时，继续以上循环。 解题思路如上，稍微较坑的就是需要考虑起始点是否有加油站，若没有，则最远的行程为0.00。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1061]]></title>
    <url>%2F2018%2F03%2F09%2FPAT1061%2F</url>
    <content type="text"><![CDATA[PAT1061. Dating (20) 题目 代码 #include &lt;iostream> #include &lt;cctype> #include &lt;vector> #include &lt;string> #include &lt;iomanip> using namespace std; int main() { const vector&lt;string> days = {"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"}; string s1, s2; std::cin >> s1 >> s2; vector&lt;int> indexs(3, 0); for (int i = 0, t = 0; i &lt; s1.size() &amp;&amp; i &lt; s2.size(); ++i) { if (t == 2) { break; } if (s1[i] == s2[i]) { if (t == 0) { if (isupper(s1[i]) &amp;&amp; s1[i] &lt; 'H') { indexs[t] = s1[i] - 'A'; ++t; } } else { if (isalpha(s1[i]) &amp;&amp; s1[i] &lt; 'O') { indexs[t] = s1[i] - 'A' + 10; ++t; } else if (isalnum(s1[i]) &amp;&amp; !isalpha(s1[i])) { indexs[t] = s1[i] - '0'; ++t; } } } } string s3, s4; std::cin >> s3 >> s4; for (int i = 0; i &lt; s3.size() &amp;&amp; i &lt; s4.size(); ++i) { if (s3[i] == s4[i] &amp;&amp; isalpha(s3[i])) { indexs[2] = i; } } cout &lt;&lt; days[indexs[0]] &lt;&lt; " " &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; indexs[1] &lt;&lt; ":" &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; indexs[2]; return 0; } 总结很简单的一道题，但是坑却不少，需要注意的点： 防止越界，排除不可能的选项。 注意格式 字符‘0’和数字0……]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理阅读笔记二]]></title>
    <url>%2F2018%2F03%2F08%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[第二章 数字图像基础1.视觉感知要素大致讲了人眼的构造（人眼包含两种视觉细胞，锥状体对色彩敏感，杆状体对能给出视野内一般的总体图像，没有色彩感觉）和成像原理，以及一些典型的视觉错觉。 2.光和电磁波谱略 3.图像感知和获取简单的图像形成模型用$f(x,y)$二维函数形式表示图像，$f(x,y)$一定是非零和有限的，这就是:$$0&lt;f(x,y)&lt;\infty $$函数$f(x,y)$可以用两个分量来表征：入射分量$i(x,y)$和反射分量$r(x,y)$，合成形式如下：$$f(x,y)=i(x,y)r(x,y)$$这里：$$0&lt;i(x,y)&lt;\infty $$$$0&lt;r(x,y)&lt;1$$反射分量是1时代表全反射，为0时代表全吸收。 我们称单色图像在任何坐标$(x_{0},y_{0})$处的强度为图像在那一点的灰度级$(l)$,即$$l=f(x_{0},y_{0})$$且其范围为$$L_{min}\leqslant l\leqslant L_{max}$$区间$[L_{min},L_{max}]$称为灰度级，实际常常令该区间为$[0,L-1]$，此时$l=0$为黑，$l=L-1$在灰度级中为白。所有中间值是从黑到白的各种灰色调。 4.图像取样和量化取样和量化是将物理图像转化为数字图像的重要手段。 数字图像表示本书中，假设在取样和量化后产生的图像有M行N列，则图像表示为:$$f(x,y)=\begin{bmatrix} f(0,0)&amp; f(0,1)&amp; \cdots &amp; f(0,N-1) \\ f(1,0)&amp; f(1,1)&amp; \cdots &amp; f(1,N-1) \\ \vdots &amp; &amp; &amp; \\ f(M-1,0)&amp; f(M-1,1)&amp; \cdots&amp; f(M-1,N-1)\end{bmatrix}$$同样也可以用传统矩阵代表数字图像。一定要记住坐标约定，如图： 空间和灰度级分辨率两者都对图像的质量有很重要的影响。空间和灰度级分辨率越高，图像质量越好，反之越差。 放大和收缩数字图像放大可看作过采样，收缩可看作欠采样。 放大要求执行两步操作：创立新的像素位置和对这些新位置赋灰度值。有两种操作： 最近邻域内插：在原始图像上放一个虚构的750x750的栅格，很显然，栅格的间隔应小于一个像素，为了对覆盖层上的任何点进行灰度赋值，我们在原图像上寻找最靠近的像素并把它的灰度值赋给栅格上的新像素。（缺点：容易产生棋盘格效应。） 双线性内插：采用4个最邻近点的双线性内插，坐标$({x}’,{y}’)$的灰度值$v({x}’,{y}’)$如下$$v({x}’,{y}’)=a{x}’+b{y}’+c{x}’{y}’+d$$其中这里的4个系数由$({x}’,{y}’)$的4个最近邻点的4个未知方程决定。 收缩和放大操作类似，不过应注意混淆效应，需要在缩小前进行适当的模糊。 5.像素间的一些基本关系相邻像素 某像素$p$的坐标为$(x, y)$，它有上、下、左、右四个方向相邻的像素，其坐标分别为：$$(x,y-1),(x,y+1),(x-1,y),(x+1,y)$$该像素集称为$p$的4邻域，用$N_{4}(p)$来表示。如果$p$位于图像的边界，则$p$的某一邻像素位于数字图像的外部。 某像素$p$的坐标为$(x, y)$，它有左上、左下、右上、右下四个方向相邻的像素，其坐标分别为：$$(x-1,y-1),(x-1,y+1),(x+1,y-1),(x+1,y+1)$$该像素集用$N_{D}(p)$表示，并与$N_{4}(p)$结合起来称为$p$的8邻域，用$N_{8}(p)$表示。如果$p$位于图像的边界，则$p$的某一邻像素位于数字图像的外部。 邻接性、连通性、区域和边界像素间的连通性是一个基本概念，简化了很多数字图像概念的定义，如区域和边界。若保证两个像素连通，首先保证其相邻，并且其灰度值满足特定的相似（例如在某个灰度级集合V中）准则。 先考虑三种类型的邻接性： 4邻接：若像素$q$在$N_{4}(p)$中，且像素$p$和像素$q$的灰度级相似，则两像素是4邻接的。 8邻接：若像素$q$在$N_{8}(p)$中，且像素$p$和像素$q$的灰度级相似，则两像素是4邻接的。 m邻接（混合邻接）：若(i)像素$q$在$N_{4}(p)$中，或者(ii)像素$q$在$N_{D}(p)$中，且像素$p$和像素$q$的灰度级相似，且集合$N_{4}(p)\bigcap N_{4}(q)$中的像素都不与q和p相似，则两像素是m邻接的。有个比较好的网站，便于理解。 当一系列邻接的像素点构成的序列即可以称为通路，4邻接就叫做4通路，8邻接叫做8通路，m邻接叫做m通路。 令S代表一幅图像中像素的子集，若S中只有一条通路，则称该集合为连通集，也可以称之为区域（通常用R表示）。 一个区域R的边界（也称为边缘和轮廓）是区域中像素的集合，这些像素点有一个或多个不再R中的邻点。 边缘的概念和边界的概念：一个有限区域的边界形成一条闭合通路，并且是“整体”概念，边缘的概念是基于在不连续点进行灰度级测量的局部概念，把边缘点连接成边缘线段是可能的。从二值区域提取边缘与提取区域边界是一样的。在概念上，把边缘考虑为强度不连续的点和封闭通路的边界是有帮助的。 距离度量假设$p$和$q$的坐标分别为$(x,y)$,$(s,t)$$p$和$q$间的欧式距离定义：$$D(p,q)=[(x-s)^{2}+(y-t)^{2}]^{\frac{1}{2}}$$$p$和$q$间的$D_{4}$距离（也叫城市街区距离）定义：$$D(p,q)=\left | x-s \right |+\left | y-t \right |$$如下图所示： $p$和$q$间的$D_{8}$距离（也叫棋盘距离）定义：$$D(p,q)=max(\left | x-s \right |,\left | y-t \right |)$$如下图所示： 注意$p$和$q$之间的$D_{4}$和$D_{8}$距离与任何通路无关，仅与点的坐标有关，但是考虑m邻接时，则两点间的$D_{m}$距离用点间最短的通路定义。例如，考虑如下图： 假设$p$，$p_{2}$，$p_{4}$都为1，$p_{1}$，$p_{3}$为1或0，分下列情况分析： 若$p_{1}$，$p_{3}$都为0时，$p$到$p_{4}$距离为2，通路通过点为$p p2 p4$。 若$p_{1}=1$，$p_{3}=0$或$p_{1}=0$，$p_{3}=1$时，$p$到$p_{4}$距离为3，通路通过点为$p p1 p2 p4$或$p p2 p3 p4$。 若$p_{1}=1$，$p_{3}=1$时，$p$到$p_{4}$距离为5，通路通过点为$p p1 p2 p3 p4$。 基于像素的图像操作大多都是相对应像素间的操作。 6.线性和非线性操作令$H$是一种算子，其输入和输出都是图像。如果对于任何两幅图像$f$和$g$及任何两个标量有如下关系，则称$H$为线性算子：$$H(af+bg)=aH(f)+bH(g)$$线性算子在图像处理中特别重要，因为它们是充分了解理论和实践结果的主要基础。非线性算子也会提供较好的性能，但它们不是总可以预测的，大部分不能在理论上很好的理解。]]></content>
      <tags>
        <tag>Digital Image Processing</tag>
        <tag>冈萨雷斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1058]]></title>
    <url>%2F2018%2F03%2F06%2FPAT1058%2F</url>
    <content type="text"><![CDATA[PAT1058. A+B in Hogwarts (20) 题目 代码 #include &lt;iostream> #include &lt;cstring> #include &lt;string> #include &lt;sstream> #include &lt;vector> using namespace std; class Hogwarts { public: vector&lt;int> num; Hogwarts(string str) { char ch[20]; strcpy(ch, str.c_str()); char *ptr = strtok(ch, "."); while (ptr != NULL) { int n; stringstream ss(ptr); ss >> n; num.push_back(n); ptr = strtok(NULL, "."); } } Hogwarts(int G, int S, int K) { num.push_back(G); num.push_back(S); num.push_back(K); } friend Hogwarts operator+(const Hogwarts one, const Hogwarts two){ int K = (one.num[2] + two.num[2]) % 29; int carry = (one.num[2] + two.num[2]) / 29; int S = (one.num[1] + two.num[1] + carry) % 17; carry = (one.num[1] + two.num[1] + carry) / 17; int G = one.num[0] + two.num[0] + carry; Hogwarts three(G, S, K); return three; } void print() { cout &lt;&lt; num[0] &lt;&lt; "." &lt;&lt; num[1] &lt;&lt; "." &lt;&lt; num[2]; } }; int main() { string s1, s2; cin >> s1 >> s2; Hogwarts h1(s1); Hogwarts h2(s2); Hogwarts h3 = h1 + h2; h3.print(); return 0; } 总结很简单的一道题，简单的用了面向对象的方法，创建了Hogwarts类，重载了加法，完成了本题。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理阅读笔记一]]></title>
    <url>%2F2018%2F03%2F06%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[第一章 绪论数字图像处理的概念有三种典型的计算处理（低中高级）。 低级处理是以输入、输出都是图像为特点的处理（降低噪声的图像预处理，对比度增强和图像尖锐化）。 中级处理是以输入为图像，但输出是从这些图像中提取的特征（如边缘、轮廓及不同物体的标识等）为特点的。中级处理涉及分割（把图像分成不同区域或目标物）以及缩减对目标物的描述，以使其更适合计算机处理及对不同目标的分类（识别）。 高级处理涉及在图像分析中被识别物体的总体理解，以及执行与视觉相关的识别函数（处在连续统一体边缘）等。 数字图像处理的起源数字图像处理的基础是大规模的存储和显示系统，简而言之，计算机的发展促成了数字图像处理的发展，继而应用到各个方面：航天，医学等等。 数字图像处理的应用实例应用很广泛，不再详谈。 数字图像处理的基本步骤下图是一个概括，大致的描述数字图像处理的步骤，但不一定全部涉及。 图像获取是第一步处理，通常图像获取包括设置比例尺等预处理。 图像增强是数字图像处理中最简单和最有吸引力的地方，思路是显现那些被模糊了的细节，或简单地突出一幅图像中感兴趣的部分。记住，图像增强是图像处理中非常主观的领域。 图像复原是客观的，倾向于以图像退化的数学或概率模型为基础。 彩色图像处理是一个很重要的领域，包含彩色模型，数字域的彩色处理方面的很多概念。在后续章节中，彩色还是图像中感兴趣特征被提取的基础，小波是在各种分辨率下描述图像的基础。 压缩，所涉及的技术是减少图像的存储量，或者在传输图像时降低频带。 形态学处理涉及提取图像元素的工具，在表现和描述形状方面非常有用。 分割过程将一幅图像划分为组成成分或目标物。通常分割是图像处理最困难的任务之一。 表示与描述几乎总是跟随在分割步骤的输出后边。 识别是基于目标的描述给目标赋以符号的过程。 图像处理系统的部件大致如下，简洁直白：]]></content>
      <tags>
        <tag>Digital Image Processing</tag>
        <tag>冈萨雷斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs231n笔记一]]></title>
    <url>%2F2018%2F03%2F05%2Fcs231n%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[验证集If you wish to apply KNN in practice, proceed as follows: Split your training data randomly into train/val splits. As a rule of thumb, between 70~90% of your data usually goes to the train split. If there are many hyperparameters to estimate, you should err on the side of having larger validation set, 验证集是用来测试不同的hyperparameter（超参数）而产生的。因为对于不同的超参数，测试集是万万不能用来测试这些超参数的，训练集只能用来检验该分类器的分类效果，不到最后检测环节是不可以使用的。因此验证集应运而生。 cross-validation 更精致，但是也更费时，当training dataset比较小的时候，可以尝试。 Linear ClassificationOverview: A powerful approach to image classification will have two major components: score function and loss function. $$f(x_{i},W,b)=Wx_{i}+b$$]]></content>
      <tags>
        <tag>cs231n</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1030]]></title>
    <url>%2F2018%2F02%2F27%2FPAT1030%2F</url>
    <content type="text"><![CDATA[PAT1030. Travel Plan (30) 题目 代码 #include &lt;iostream> #include &lt;vector> using namespace std; const int inf = 99999999; vector&lt;vector&lt;int>> getPathFromStartToThisPoint(int point, vector&lt;vector&lt;int>> &amp;pre) { if (pre[point][0] == -1) { return vector&lt;vector&lt;int>>(1, vector&lt;int>(1, point)); } else { vector&lt;vector&lt;int>> childpath; vector&lt;vector&lt;int>> resultpath; for (int i = 0; i &lt; pre[point].size(); ++i) { childpath = getPathFromStartToThisPoint(pre[point][i], pre); for (int j = 0; j &lt; childpath.size(); ++j) { childpath[j].push_back(point); } if (resultpath.empty()) { resultpath = childpath; } else { resultpath.insert(resultpath.end(), childpath.begin(), childpath.end()); } } return resultpath; } } int main() { int cityNum, highwayNum, start, destination; cin >> cityNum >> highwayNum >> start >> destination; vector&lt;vector&lt;int>> Graph(cityNum, vector&lt;int>(cityNum, inf)); vector&lt;vector&lt;int>> Cost(cityNum, vector&lt;int>(cityNum, inf)); vector&lt;bool> visited(cityNum, false); for (int i = 0; i &lt; highwayNum; ++i) { int c1, c2, dist, cost; cin >> c1 >> c2 >> dist >> cost; Graph[c1][c2] = dist; Graph[c2][c1] = dist; Cost[c1][c2] = cost; Cost[c2][c1] = cost; } vector&lt;vector&lt;int>> pre(cityNum); pre[start].push_back(-1); vector&lt;int> shortestDist(cityNum, inf); shortestDist[start] = 0; //dijkstra for (int i = 0; i &lt; cityNum; ++i) { // choose point int min = inf; int index = -1; for (int j = 0; j &lt; cityNum; ++j) { if (!visited[j] &amp;&amp; min > shortestDist[j]) { min = shortestDist[j]; index = j; } } visited[index] = true; // relax for (int j = 0; j &lt; cityNum; ++j) { if (shortestDist[j] > shortestDist[index] + Graph[index][j]) { shortestDist[j] = shortestDist[index] + Graph[index][j]; pre[j].clear(); pre[j].push_back(index); } else if (shortestDist[j] == shortestDist[index] + Graph[index][j]) { pre[j].push_back(index); } } } vector&lt;vector&lt;int>> paths = getPathFromStartToThisPoint(destination, pre); int minCost = inf; int minIndex = -1; for (int j = 0; j &lt; paths.size(); ++j) { int costtmp = 0; for (int i = 0; i &lt; paths[j].size() - 1; ++i) { costtmp += Cost[paths[j][i]][paths[j][i + 1]]; } if (minCost > costtmp) { minCost = costtmp; minIndex = j; } } for (auto elem : paths[minIndex]) { cout &lt;&lt; elem &lt;&lt; " "; } cout &lt;&lt; shortestDist[destination] &lt;&lt; " " &lt;&lt; minCost; return 0; } 总结这道题和PAT1018非常类似，甚至比1018要简单，原理还是一样：找出所有最短路径，再按照题中要求求得最符合要求的哪一条路径即可。 图数据结构（二维矩阵）中同一点之间的距离不再初始化为0，而是初始化为无穷大，防止在之后添加前向点的时候把自身这个点也添加进去，稍微改进了一下dijkstra部分的代码，以及回溯路径的代码，但实际上差不多。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1028]]></title>
    <url>%2F2018%2F02%2F27%2FPAT1028%2F</url>
    <content type="text"><![CDATA[PAT1028. List Sorting (25) 题目 代码 #include &lt;iostream> #include &lt;vector> #include &lt;string> #include &lt;algorithm> using namespace std; int type = 0; struct Student { string ID; string name; int score; bool operator&lt;(const Student &amp;other) const { if (type == 1) { return ID &lt; other.ID; } else if (type == 2) { return name &lt; other.name || !(other.name &lt; name) &amp;&amp; ID &lt; other.ID; } else if (type == 3) { return score &lt; other.score || !(other.score &lt; score) &amp;&amp; ID &lt; other.ID; } else { throw exception(); } } }; int main() { int numRecord, columnIndex; scanf("%d%d", &amp;numRecord, &amp;columnIndex); type = columnIndex; vector&lt;Student> students; for (int i = 0; i &lt; numRecord; ++i) { char idChar[10], nameChar[10]; int score; scanf("%s%s%d", idChar, nameChar, &amp;score); Student stu; string id(idChar), name(nameChar); stu.ID = id; stu.name = name; stu.score = score; students.push_back(stu); } sort(students.begin(), students.end(), less&lt;Student>()); for (auto stu : students) { printf("%s %s %d\n", stu.ID.c_str(), stu.name.c_str(), stu.score); } return 0; } 总结这道题非常简单，简单的可以直接到20分的题中了，不过还是一次没提交成功，主要原因是对于多数据N (&lt;=100000)的输入输出还是需要scanf和printf啊，很快，即使取消了同步的cin和cout还是要慢很多……搞得我想直接放弃cin和cout了…… 另一种读入string的方法是 for (int i = 0; i &lt; numRecord; ++i) { Student stu; string id, name; int score; id.resize(10); name.resize(10); scanf("%s%s%d", id.c_str(), name.c_str(), &amp;score); stu.ID = id; stu.name = name; stu.score = score; students.push_back(stu); } 两者速度相差不多。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1024]]></title>
    <url>%2F2018%2F02%2F25%2FPAT1024%2F</url>
    <content type="text"><![CDATA[PAT1024. Palindromic Number (25) 题目 代码 #include &lt;iostream> #include &lt;sstream> #include &lt;string> #include &lt;algorithm> #include &lt;vector> using namespace std; //long long str2longlong(string numStr) { // long long num; // stringstream ss; // ss &lt;&lt; numStr; // ss >> num; // ss.clear(); // return num; //} // //string longlong2str(long long num) { // string numStr; // stringstream ss; // ss &lt;&lt; num; // ss >> numStr; // ss.clear(); // return numStr; //} bool isPalindromic(string str) { int len = str.size(); for (int i = 0; i &lt; len /2; ++i) { if (str[i] != str[len - 1 - i]) { return false; } } return true; } string add(string s1, string s2) { int minLen = s1.size() &lt; s2.size() ? s1.size() : s2.size(); vector&lt;int> result; int s1Len = s1.size(); int s2Len = s2.size(); int carry = 0; for (int i = 0; i &lt; minLen; ++i) { int tmp = s1[s1Len - 1 - i] + s2[s2Len - 1 - i] + carry - 2 * '0'; carry = 0; if (tmp > 9) { carry = tmp / 10; tmp -= 10; } result.push_back(tmp); } if (carry) { result.push_back(carry); } string resStr(result.size(), '0'); int resLen = result.size(); for (int i = 0; i &lt; resLen; ++i) { resStr[i] = result[resLen - 1 - i] + '0'; } return resStr; } int main() { ios::sync_with_stdio(false); string numStr; int maxTimes; cin >> numStr >> maxTimes; string tmpStr(numStr); int times = 0; for (int i = 0; i &lt; maxTimes; ++i) { if (!isPalindromic(tmpStr)) { string resTmpStr(tmpStr); reverse(resTmpStr.begin(), resTmpStr.end()); tmpStr = add(tmpStr, resTmpStr); ++times; } } cout &lt;&lt; tmpStr &lt;&lt; endl; cout &lt;&lt; times &lt;&lt; endl; return 0; } 总结此题是考察的是大数的简易相加问题，说实话一开始对于题目要求是 N (&lt;= 1000000000) 个人认为long long整型数是可以满足此题要求的，但总是有第6，8测试点不通过，仔细想了想如果是100步的话，可能真的不行，long long的范围是-9223372036854775808～+9223372036854775807。例如，对于99这个数来说，此种加法过程第一步达到198，第二步达到1089，第三步达到10890，以此类推，每2步增加1位。经计算，99第100步能够达到9924442828917149695640474870516109271445388，已经超出了long long的范围，所以需要大数加法，如上述代码所示。 不过在解决long long和string类型转换的时候也了解到一点知识，直接使用stringstream很快捷也很方便，string转其他类型也是同样的道理： long long str2longlong(string numStr) { long long num; stringstream ss; ss &lt;&lt; numStr; ss >> num; ss.clear(); return num; } string longlong2str(long long num) { string numStr; stringstream ss; ss &lt;&lt; num; ss >> numStr; ss.clear(); return numStr; }]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1022]]></title>
    <url>%2F2018%2F02%2F24%2FPAT1022%2F</url>
    <content type="text"><![CDATA[PAT1022. Digital Library (30) 题目 代码 #include &lt;iostream> #include &lt;vector> #include &lt;cstring> #include &lt;string> #include &lt;map> #include &lt;functional> #include &lt;algorithm> using namespace std; // thread un-safe, single thread is safe void splitSpace(string rawString, vector&lt;string> &amp;subStrings) { char rawChars[60]; strcpy(rawChars, rawString.c_str()); char* pch = strtok(rawChars, " "); while (pch != NULL) { string subString(pch); subStrings.push_back(subString); pch = strtok(NULL, " "); } } void storeInfo(map&lt;string, vector&lt;string>> &amp;storeMap, string key, string ID) { // exist if (storeMap.find(key) != storeMap.end()) { storeMap[key].push_back(ID); } // not exist else { vector&lt;string> tmp; tmp.push_back(ID); storeMap.insert(make_pair(key, tmp)); } } void printInfo(map&lt;string, vector&lt;string>> &amp;storeMap, string key) { // exist if (storeMap.find(key) != storeMap.end()) { vector&lt;string> tmp = storeMap[key]; sort(tmp.begin(), tmp.end(), less&lt;string>()); for (auto elem : tmp) { cout &lt;&lt; elem &lt;&lt; endl; } } // not exist else { cout &lt;&lt; "Not Found" &lt;&lt; endl; } } int main() { ios::sync_with_stdio(false); int numBook; cin >> numBook; // data struct map&lt;string, vector&lt;string>> titleMaps; map&lt;string, vector&lt;string>> authorMaps; map&lt;string, vector&lt;string>> keywordMaps; map&lt;string, vector&lt;string>> publisherMaps; map&lt;string, vector&lt;string>> yearMaps; for (int i = 0; i &lt; numBook; ++i) { string ID, title, author, publisher, rawKeywords, year; vector&lt;string> keywords; cin >> ID; cin.ignore(); getline(cin, title); getline(cin, author); getline(cin, rawKeywords); splitSpace(rawKeywords, keywords); getline(cin, publisher); getline(cin, year); // store infomation storeInfo(titleMaps, title, ID); storeInfo(authorMaps, author, ID); for (auto elem : keywords) { storeInfo(keywordMaps, elem, ID); } storeInfo(publisherMaps, publisher, ID); storeInfo(yearMaps, year, ID); } int numQuery; vector&lt;string> entryQuerys; cin >> numQuery; cin.ignore(); for (int i = 0; i &lt; numQuery; ++i) { string entry; getline(cin, entry); entryQuerys.push_back(entry); } // print for (auto item : entryQuerys) { cout &lt;&lt; item &lt;&lt; endl; char type = item[0]; switch (type) { case '1': printInfo(titleMaps, item.substr(3, item.size() - 3)); break; case '2': printInfo(authorMaps, item.substr(3, item.size() - 3)); break; case '3': printInfo(keywordMaps, item.substr(3, item.size() - 3)); break; case '4': printInfo(publisherMaps, item.substr(3, item.size() - 3)); break; case '5': printInfo(yearMaps, item.substr(3, item.size() - 3)); break; default: break; } } return 0; } 总结这道题相对比较简单（在30分的类别中来说），更多的是对输入数据和存储数据，以及调用数据的考察。使用STL中的map数据结构为主。 注意几个要点： 1. getline()函数在cin之后使用，需要在cin之后加上cin.ignore()来忽略&#39;\n&#39;，防止getline()使用出错。 2. 对于书本的ID来说，推荐使用字符串，如果使用了整型，记得在输出结果的时候注意7位格式 3. 由于c++中没有java里的split函数，所以可以注意一下splitSpace()函数（该函数中的strtok()函数是线程不安全的，由于使用到了静态内存区域），供以后使用。 4. ios::sync_with_stdio(false);这句的意思是关闭流对象和stdio之间的同步，以提高cin，cout的速度，但是不能共用cin和scanf或者cout和printf。 // thread un-safe, single thread is safe void splitSpace(string rawString, vector&lt;string> &amp;subStrings) { char rawChars[60]; strcpy(rawChars, rawString.c_str()); char* pch = strtok(rawChars, " "); while (pch != NULL) { string subString(pch); subStrings.push_back(subString); pch = strtok(NULL, " "); } }]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1021]]></title>
    <url>%2F2018%2F02%2F24%2FPAT1021%2F</url>
    <content type="text"><![CDATA[PAT1021. Deepest Root (25) 题目 代码 #include &lt;iostream> #include &lt;vector> using namespace std; int getDepthOfTreeByRoot(const vector&lt;vector&lt;int>> &amp;Graph, vector&lt;bool> &amp;visited, int root) { int depth = 0; bool hasChildFlag = false; visited[root] = true; for (int i = 0; i &lt; Graph[root].size(); ++i) { if (!visited[Graph[root][i]]) { hasChildFlag = true; int curDepth = getDepthOfTreeByRoot(Graph, visited, Graph[root][i]); if (depth &lt; curDepth) { depth = curDepth; } } } if (hasChildFlag) { depth++; } return depth; } void getRootsOfMaxDepth(vector&lt;int> &amp;roots, const vector&lt;vector&lt;int>> &amp;Graph) { int MaxDepth = -1; int num = Graph.size(); for (int i = 1; i &lt; num; ++i) { vector&lt;bool> visited(num, false); int depth = getDepthOfTreeByRoot(Graph, visited, i); if (depth > MaxDepth) { MaxDepth = depth; roots.clear(); roots.push_back(i); } else if (depth == MaxDepth) { roots.push_back(i); } } } void Traversal(const vector&lt;vector&lt;int>> &amp;Graph, int root, vector&lt;bool> &amp;visited) { visited[root] = true; for (int i = 0; i &lt; Graph[root].size(); ++i) { if (!visited[Graph[root][i]]) { Traversal(Graph, Graph[root][i], visited); } } } int nextVisited(vector&lt;bool> &amp;visited) { int index = 1; for (; index &lt; visited.size(); ++index) { if (visited[index] == false) { return index; } } if(index == visited.size()) return 0; } int getComponentNum(const vector&lt;vector&lt;int>> &amp;Graph) { vector&lt;bool> visited(Graph.size(), false); int index = nextVisited(visited); int k = 0; while (index) { Traversal(Graph, index, visited); ++k; index = nextVisited(visited); } return k; } int main() { int N; cin >> N; vector&lt;vector&lt;int>> Graph(N + 1); for (int i = 0; i &lt; N - 1; ++i) { int a1, a2; cin >> a1 >> a2; Graph[a1].push_back(a2); Graph[a2].push_back(a1); } int k = getComponentNum(Graph); if (k == 1) { vector&lt;int> resultRoots; getRootsOfMaxDepth(resultRoots, Graph); for (auto elem : resultRoots) { cout &lt;&lt; elem &lt;&lt; endl; } } else { cout &lt;&lt; "Error: " &lt;&lt; k &lt;&lt; " components"; } return 0; } 总结这道题是首先先判断该图是不是一棵树，如果是，求树的深度，如果不是，求几部分。判断该图是树的方法就是遍历整个图，如果一次遍历完就是树。求树的深度也很简单，用递归的方法，分别求子树的深度，取得某一个子树深度最大的数+1即可，如上述代码所写即可。图的数据结构类似邻接链表，不过是用vector来实现的。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1018]]></title>
    <url>%2F2018%2F02%2F24%2FPAT1018%2F</url>
    <content type="text"><![CDATA[PAT1018. Public Bike Management (30) 题目 代码#include &lt;iostream> #include &lt;vector> using namespace std; const int inf = 99999999; // define start is 0 vector&lt;vector&lt;int>> getPathFromStart(int index, vector&lt;vector&lt;int>> &amp;prePoints) { vector&lt;vector&lt;int>> childPath; vector&lt;vector&lt;int>> resultPath; if (index != 0) { for (int i = 0; i &lt; prePoints[index].size(); ++i) { childPath = getPathFromStart(prePoints[index][i], prePoints); for (int j = 0; j &lt; childPath.size(); ++j) { childPath[j].push_back(index); } if (resultPath.empty()) resultPath = childPath; else resultPath.insert(resultPath.end(), childPath.begin(), childPath.end()); } } else { resultPath.push_back(vector&lt;int>(1, 0)); } return resultPath; } void getTakeAndBack(vector&lt;int> &amp;path, vector&lt;int> &amp;capacitys, int CMax, int &amp;take, int &amp;back) { take = 0; back = 0; vector&lt;int> tmpArray(path.size()); for (int i = 1; i &lt; path.size(); ++i) { tmpArray[i] = capacitys[path[i]] - CMax/2; } int tmp = 0; for (int i = 1; i &lt; tmpArray.size(); ++i) { // if tmpArray[i] smaller than zero, it means that must take the bike from PBMC if (tmpArray[i] &lt; 0) { // it means that it can supply bike from before station if (tmp > -tmpArray[i]) { tmp += tmpArray[i]; } // it means that it dont have enough bike, so it need to take bike from PBMC else { tmp += tmpArray[i]; take -= tmp; tmp = 0; } } // it means that it have redundant bike so record it else { tmp += tmpArray[i]; } } back = tmp; } int main() { int CMax, N, Sp, M; cin >> CMax >> N >> Sp >> M; vector&lt;int> capacitys(N + 1); // graph struct vector&lt;vector&lt;int>> Graph(N + 1, vector&lt;int>(N + 1, inf)); for (int i = 0; i &lt; N + 1; ++i) { Graph[i][i] = 0; } for (int i = 1; i &lt; N + 1; ++i) { cin >> capacitys[i]; } for (int i = 0; i &lt; M; ++i) { int startIndex, endIndex, roadLen; cin >> startIndex >> endIndex >> roadLen; Graph[startIndex][endIndex] = roadLen; Graph[endIndex][startIndex] = roadLen; } // prePoints vector&lt;vector&lt;int>> prePoints(N + 1); //for (int i = 0; i &lt; N + 1; ++i) { // if (Graph[0][i] != inf) { // prePoints[i].push_back(0); // } //} //prePoints[0][0] = -1; // dijkstra vector&lt;int> shortestDist(N + 1, inf); vector&lt;bool> visited(N + 1, false); // define strat point shortestDist[0] = 0; for (int i = 0; i &lt; N + 1; ++i) { // choose shortest distance int index, min = inf; for (int t = 0; t &lt; N + 1; ++t) { if (!visited[t] &amp;&amp; min > shortestDist[t]) { min = shortestDist[t]; index = t; } } //relax for (int j = 0; j &lt; N + 1; ++j) { if (shortestDist[j] > shortestDist[index] + Graph[index][j]) { shortestDist[j] = shortestDist[index] + Graph[index][j]; prePoints[j].clear(); prePoints[j].push_back(index); } else if (shortestDist[j] == shortestDist[index] + Graph[index][j]) { if (j != index) { prePoints[j].push_back(index); } } } visited[index] = true; } vector&lt;vector&lt;int>> paths = getPathFromStart(Sp, prePoints); vector&lt;int> ansPath; int pathIndex; int minTake = inf, minBack = inf; for (int i = 0; i &lt; paths.size(); ++i) { int take, back; getTakeAndBack(paths[i], capacitys, CMax, take, back); if (minTake > take) { minTake = take; minBack = back; pathIndex = i; } else if (minTake == take) { if (minBack > back) { minBack = back; pathIndex = i; minBack = back; } } } ansPath = paths[pathIndex]; //print cout &lt;&lt; minTake &lt;&lt; " 0"; for (int i = 1; i &lt; ansPath.size(); ++i) { cout &lt;&lt; "->" &lt;&lt; ansPath[i]; } cout &lt;&lt; " " &lt;&lt; minBack; return 0; } 总结这道题涉及的东西比较多，首先需要dijkstra来求出最短路径的距离，其间通过递归求得路径。通过所求得的路径，从起点开始到终点计算所需要带来和带回的自行车数量。 对于Dijkstra，如果图结构是二维数组的话，两层循环即可，可以简化成以下模板，供以后使用： // dijkstra // graph struct vector&lt;vector&lt;int>> Graph(N + 1, vector&lt;int>(N + 1, inf)); vector&lt;int> shortestDist(N + 1, inf); vector&lt;bool> visited(N + 1, false); // define strat point shortestDist[0] = 0; for (int i = 0; i &lt; N + 1; ++i) { // choose shortest distance int index, min = inf; for (int t = 0; t &lt; N + 1; ++t) { if (!visited[t] &amp;&amp; min > shortestDist[t]) { min = shortestDist[t]; index = t; } } //relax for (int j = 0; j &lt; N + 1; ++j) { if (shortestDist[j] > shortestDist[index] + Graph[index][j]) { shortestDist[j] = shortestDist[index] + Graph[index][j]; } } visited[index] = true; } 其中，getPathFromStart()函数用来递归求得路径并且保存路径也值得多次琢磨。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习中一些注意点]]></title>
    <url>%2F2017%2F10%2F11%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Python学习中一些注意点一、参数默认值使用参数默认值时，必须小心指定了可变动对象时的一个陷阱，Python在执行到def时，就会按照定义创建相关的资源，如下： def prepend(elem, lt = []): lt.insert(0, elem) return lt print(prepend(10)) print(prepend(10, [20, 30, 40])) print(prepend(20)) 结果如下：在上例中，lt默认值设置为[]，由于def是条语句，执行到def的函数定义时就创建了[]，而这个列表对象会一直存在，如果没有指定lt，使用的一直就会使一开始指定的列表对象，因此随着每次调用都不指定lt的值，前置的目标列表都会是同一个列表，因此会出现上面的问题。 想要避免这样的问题，可以将参数默认值设置为None，并且在函数中指定真正的默认值，如下: def prepend(elem, lt = None): lt = lt if lt else [] lt.insert(0, elem) return lt print(prepend(10)) print(prepend(10, [20, 30, 40])) print(prepend(20)) 结果如下：]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习中一些比较好的网站]]></title>
    <url>%2F2017%2F09%2F25%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%A5%BD%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Python学习中一些比较好的网站图解 Python 深拷贝和浅拷贝Python中，对象的赋值，拷贝（深/浅拷贝）之间是有差异的，如果使用的时候不注意，就可能产生意外的结果。 下面本文就通过简单的例子介绍一下这些概念之间的差别。http://python.jobbole.com/82294/]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个Windows程序]]></title>
    <url>%2F2017%2F07%2F30%2F%E7%AC%AC%E4%B8%80%E4%B8%AAWindows%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言按照上篇博客所写的流程，可以创建第一个Windows程序： 定义WinMain()函数 创建一个窗口类2.1 设计窗口2.2 创建窗口2.3 注册窗口2.4 显示，更新窗口 消息队列 窗口过程函数 代码#include &lt;windows.h> #include &lt;stdio.h> #include &lt;tchar.h> LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); int WINAPI WinMain( HINSTANCE hInstance, //当前程序运行实例句柄 HINSTANCE hPrevInstance, //当前实例的前一个实例句柄，一般为NULL LPSTR lpCmdLine, //命令行参数 int nCmdShow ) { //设计一个窗口类 WNDCLASS wndcls; wndcls.cbClsExtra = 0; wndcls.cbWndExtra = 0; wndcls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); wndcls.hCursor = LoadCursor(NULL, IDC_ARROW); wndcls.hIcon = LoadIcon(NULL, IDI_QUESTION); wndcls.hInstance = hInstance; wndcls.lpfnWndProc = WindowProc; wndcls.lpszClassName = _T("donggeok"); wndcls.lpszMenuName = NULL; wndcls.style = CS_HREDRAW | CS_VREDRAW; //注册窗口类 RegisterClass(&amp;wndcls); //创建窗口 HWND hwnd; hwnd = CreateWindow(_T("donggeok"), _T("hehe"), WS_OVERLAPPEDWINDOW, 0, 0, 600, 400, NULL, NULL, hInstance, NULL); //显示及更新窗口 ShowWindow(hwnd, SW_NORMAL); UpdateWindow(hwnd); //定义消息结构体，消息循环 MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } return msg.wParam; } //消息过程函数 LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) { switch (uMsg) { case WM_CHAR: { char szChar[30] = { 0 }; sprintf_s(szChar, "char code is %c", wParam); WCHAR wszStr[256]; memset(wszStr, 0, sizeof(wszStr)); MultiByteToWideChar(CP_ACP, 0, szChar, strlen(szChar) + 1, wszStr, sizeof(wszStr) / sizeof(wszStr[0])); MessageBox(hwnd, wszStr, _T("char"), 0); break; } case WM_LBUTTONDOWN: MessageBox(hwnd, _T("mouse clicked"), _T("message"), 0); HDC hdc; hdc = GetDC(hwnd); TextOut(hdc, 0, 50, _T("heheheh"), strlen("heheheh")); ReleaseDC(hwnd, hdc); break; case WM_PAINT: HDC hDc; PAINTSTRUCT ps; hDc = BeginPaint(hwnd, &amp;ps); TextOut(hDc, 0, 0, _T("aaaaa"), 5); EndPaint(hwnd, &amp;ps); break; case WM_CLOSE: if (IDYES == MessageBox(hwnd, _T("really end?"), _T("message"), MB_YESNO)) { DestroyWindow(hwnd); } break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hwnd, uMsg, wParam, lParam); } return 0; } 结果]]></content>
      <tags>
        <tag>实习</tag>
        <tag>windows编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows程序内部机制]]></title>
    <url>%2F2017%2F07%2F29%2Fwindows%E7%A8%8B%E5%BA%8F%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[windows程序内部运行机制窗口和句柄在Windows应用程序中，窗口是通过窗口句柄（HWND）来标识的。要对一个窗口操作，首先获得该窗口的句柄。同时，系统在创建资源（窗口、图标、光标等）时会分配内存，并且返回标识这些资源的标识号，即句柄。 消息在Windows程序中，消息是由MSG结构体来表示的。其结构定义如下： typedef struct tagMSG { HWND hwnd; //消息所属窗口 UINT message; //消息标识符 WPARAM wParam; //消息附加信息 LPARAM lParam; //消息附加信息 DWORD time; POINT pt; } WinMain函数WinMain函数原型声明如下： int WINAPI WinMain( HINSTANCE hInstance, //当前程序运行实例句柄 HINSTANCE hPrevInstance, //当前实例的前一个实例句柄，一般为NULL LPSTR lpCmdLine, //命令行参数 int nCmdShow ); 一个完整Win32程序过程WinMain函数的定义即把上述的WinMain函数。 创建一个窗口设计一个窗口类类似的，我们在设计一个窗口时，只需要将我们修改的部分填充完整即可，Windows已经为我们定义好了，其中定义的结构体就是WNDCLASS，如下： typedef struct _WNDCLASS { UINT style; //默认为CS_HREDRAW | CS_VREDRAW WNDPROC lpfnWndProc; //指向窗口过程函数 int cbClsExtra; //一般为0 int cbWndExtra; //一般为0 HANDLE hInstance; HICON hIcon; //用LoadIcon()函数，如果选用默认图标，则置为NULL， HCURSOR hCursor; //用LoadCursor()函数 HBRUSH hbrBackground; //使用GetStockObject()函数 LPCTSTR lpszMenuName; LPCTSTR lpszClassName; } WNDCLASS; 注册窗口类注册函数原型声明如下： ATOM RegisterClass(CONST WNDCLASS *lpWndClass); 创建窗口设计好窗口类并且成功注册之后，可以使用CreateWindow()函数产生这种类型的窗口，CreateWindow()函数的原型声明如下： HWND CreateWindow( LPCTSTR lpClassName, //窗口类WNDCLASS的lpszClassName成员指定的名称 LPCTSTR lpWindowName, //标题栏名字 DWORD dwStyle, //一般为WS_OVERLAPPEDWINDOW int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HANDLE hInstance, LPVOID lpParam ); 显示及更新窗口1.显示窗口创建窗口之后，需要用ShowWindow()函数让窗口显示出来，ShowWindow()函数原型声明如下： BOOL ShowWindow( HWND hWnd, int nCmdShow //一般为SW_SHOWNORMAL ); 2.更新窗口窗口显现出来后，可以紧接着调用UpdateWindow来刷新窗口，原型如下： Bool UpdateWindow( HWND hWnd, ); 消息循环创建，显示，更新完一个窗口后，我们需要编写消息循环，不断地从消息队列中取出消息，此时需要调用GetMessage()函数，原型如下： BOOL GetMessage( LPMSG lpMsg, //消息MSG结构体 HWND hWnd, //一般为NULL,代表调用线程的所有窗口的窗口消息 UINT wMsgFilterMin, //一般为0 UINT wMsgFilterMax //一般为0 ); GetMessage()函数只有在接收到WM_QUIT消息时，才返回0。TranslateMessage()函数用于将虚拟键消息转换为字符消息，可以将WM_KEYDOWN和WM_KEYUP消息组合转化为WM_CHAR消息（该消息的wParam附加参数包含字符的ASCII码），该函数不会修改原有消息，只会产生新的消息并投递倒消息队列中。DispatchMessage()函数分派一个消息到窗口过程，窗口过程函数对消息进行处理。如下图：通常我们编写的消息循环代码如下： MSG msg; while(GetMessage(&amp;msg, NULL, 0, 0)){ TranlateMessage(&amp;msg); DispatchMessage(&amp;msg); } 编写窗口过程函数完成WinMain()函数创建，以及窗口的设计，注册，创建，显示和更新，消息循环之后，剩下的工作就是编写窗口过程函数，原型如下： LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); 其中大概模板如下： LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ){ switch(uMsg){ case WM_CHAR: ...... break; case WM_LBUTTONDOWN: ...... break; case WM_PAINT: ...... break; case WM_CLOSE: ...... break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hwnd, uMsg, wParam, lParam); } return 0; } 总结对于Windows API来说，基本的流程都是这样的，了解这些过程有很大的帮助。]]></content>
      <tags>
        <tag>实习</tag>
        <tag>windows编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1001]]></title>
    <url>%2F2017%2F07%2F23%2FPAT1001%2F</url>
    <content type="text"><![CDATA[PAT1001. A+B Format (20) 题目 代码 #include &lt;iostream> #include &lt;iomanip> using namespace std; int a[10]; void formatPrint(long long n){ if(n == 0){ cout &lt;&lt; "0" &lt;&lt; endl; }else if(n &lt; 0){ long long num = -n; int i = 0; while(num != 0){ a[i] = num%1000; num = num/1000; i++; } cout &lt;&lt; "-" ; if(n > -1000){ cout &lt;&lt; a[0] &lt;&lt; endl; }else{ i--; cout &lt;&lt; a[i] &lt;&lt; ","; for(i--; i > 0; i--){ cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; a[i] &lt;&lt; ","; } cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; a[0] &lt;&lt; endl; } }else{ long long num = n; int i = 0; while(num != 0){ a[i] = num%1000; num = num/1000; i++; } if(n &lt; 1000){ cout &lt;&lt; a[0] &lt;&lt; endl; }else{ i--; cout &lt;&lt; a[i] &lt;&lt; ","; for(i--; i > 0; i--){ cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; a[i] &lt;&lt; ","; } cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; a[0] &lt;&lt; endl; } } } int main(){ long long a, b; cin >> a >> b; formatPrint(a+b); return 0; } 总结这是PAT的第一题，分值只有20分，相对比较简单，需要注意的是格式，以及了解了一下C++中对规范的设置有： &gt;cout &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(3) &lt;&lt; a[0] &lt;&lt; endl; 代表宽度为三，不足补零。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2F2017%2F07%2F23%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[#第一篇博文 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]@requires_authorization class SomeClass: pass if __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图st=>start: Start op=>operation: Your Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op 5. 高效绘制 序列图Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks! 6. 高效绘制 甘特图 title 项目开发流程 section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5d section 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5d section 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <tags>
        <tag>one</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
</search>